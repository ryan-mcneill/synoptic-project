{"ast":null,"code":"/*! Fast Average Color | Â© 2020 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */\nfunction isIgnoredColor(arr, num, ignoredColor) {\n  return arr[num] === ignoredColor[0] && // red\n  arr[num + 1] === ignoredColor[1] && // green\n  arr[num + 2] === ignoredColor[2] && // blue\n  arr[num + 3] === ignoredColor[3]; // alpha\n}\n\nfunction dominantAlgorithm(arr, len, options) {\n  const colorHash = {},\n        divider = 24,\n        ignoredColor = options.ignoredColor;\n\n  for (let i = 0; i < len; i += options.step) {\n    let red = arr[i],\n        green = arr[i + 1],\n        blue = arr[i + 2],\n        alpha = arr[i + 3];\n\n    if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n      continue;\n    }\n\n    const key = Math.round(red / divider) + ',' + Math.round(green / divider) + ',' + Math.round(blue / divider);\n\n    if (colorHash[key]) {\n      colorHash[key] = [colorHash[key][0] + red * alpha, colorHash[key][1] + green * alpha, colorHash[key][2] + blue * alpha, colorHash[key][3] + alpha, colorHash[key][4] + 1];\n    } else {\n      colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];\n    }\n  }\n\n  const buffer = Object.keys(colorHash).map(key => {\n    return colorHash[key];\n  }).sort((a, b) => {\n    const countA = a[4],\n          countB = b[4];\n    return countA > countB ? -1 : countA === countB ? 0 : 1;\n  });\n  const max = buffer[0];\n  const redTotal = max[0];\n  const greenTotal = max[1];\n  const blueTotal = max[2];\n  const alphaTotal = max[3];\n  const count = max[4];\n  return alphaTotal ? [Math.round(redTotal / alphaTotal), Math.round(greenTotal / alphaTotal), Math.round(blueTotal / alphaTotal), Math.round(alphaTotal / count)] : options.defaultColor;\n}\n\nfunction simpleAlgorithm(arr, len, options) {\n  let redTotal = 0,\n      greenTotal = 0,\n      blueTotal = 0,\n      alphaTotal = 0,\n      count = 0;\n  const ignoredColor = options.ignoredColor;\n\n  for (let i = 0; i < len; i += options.step) {\n    const alpha = arr[i + 3],\n          red = arr[i] * alpha,\n          green = arr[i + 1] * alpha,\n          blue = arr[i + 2] * alpha;\n\n    if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n      continue;\n    }\n\n    redTotal += red;\n    greenTotal += green;\n    blueTotal += blue;\n    alphaTotal += alpha;\n    count++;\n  }\n\n  return alphaTotal ? [Math.round(redTotal / alphaTotal), Math.round(greenTotal / alphaTotal), Math.round(blueTotal / alphaTotal), Math.round(alphaTotal / count)] : options.defaultColor;\n}\n\nfunction sqrtAlgorithm(arr, len, options) {\n  let redTotal = 0,\n      greenTotal = 0,\n      blueTotal = 0,\n      alphaTotal = 0,\n      count = 0;\n  const ignoredColor = options.ignoredColor;\n\n  for (let i = 0; i < len; i += options.step) {\n    const red = arr[i],\n          green = arr[i + 1],\n          blue = arr[i + 2],\n          alpha = arr[i + 3];\n\n    if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n      continue;\n    }\n\n    redTotal += red * red * alpha;\n    greenTotal += green * green * alpha;\n    blueTotal += blue * blue * alpha;\n    alphaTotal += alpha;\n    count++;\n  }\n\n  return alphaTotal ? [Math.round(Math.sqrt(redTotal / alphaTotal)), Math.round(Math.sqrt(greenTotal / alphaTotal)), Math.round(Math.sqrt(blueTotal / alphaTotal)), Math.round(alphaTotal / count)] : options.defaultColor;\n}\n\nconst ERROR_PREFIX = 'FastAverageColor: ';\n\nclass FastAverageColor {\n  /**\n   * Get asynchronously the average color from not loaded image.\n   *\n   * @param {HTMLImageElement | string | null} resource\n   * @param {Object} [options]\n   * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n   * @param {Array}  [options.ignoredColor] [red, green, blue, alpha]\n   * @param {string} [options.mode=\"speed\"] \"precision\" or \"speed\"\n   * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n   * @param {number} [options.step=1]\n   * @param {number} [options.left=0]\n   * @param {number} [options.top=0]\n   * @param {number} [options.width=width of resource]\n   * @param {number} [options.height=height of resource]\n   * @param {boolean} [options.silent] Disable error output via console.error\n   *\n   * @returns {Promise}\n   */\n  getColorAsync(resource, options) {\n    if (!resource) {\n      return Promise.reject(Error(`${ERROR_PREFIX}call .getColorAsync() without resource.`));\n    } else if (typeof resource === 'string') {\n      const img = new Image();\n      img.src = resource;\n      return this._bindImageEvents(img, options);\n    } else if (resource.complete) {\n      const result = this.getColor(resource, options);\n      return result.error ? Promise.reject(result.error) : Promise.resolve(result);\n    } else {\n      return this._bindImageEvents(resource, options);\n    }\n  }\n  /**\n   * Get the average color from images, videos and canvas.\n   *\n   * @param {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource\n   * @param {Object} [options]\n   * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n   * @param {Array}  [options.ignoredColor] [red, green, blue, alpha]\n   * @param {string} [options.mode=\"speed\"] \"precision\" or \"speed\"\n   * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n   * @param {number} [options.step=1]\n   * @param {number} [options.left=0]\n   * @param {number} [options.top=0]\n   * @param {number} [options.width=width of resource]\n   * @param {number} [options.height=height of resource]\n   * @param {boolean} [options.silent] Disable error output via console.error\n   *\n   * @returns {Object}\n   */\n\n\n  getColor(resource, options) {\n    options = options || {};\n\n    const defaultColor = this._getDefaultColor(options);\n\n    let value = defaultColor;\n\n    if (!resource) {\n      this._outputError(options, 'call .getColor(null) without resource.');\n\n      return this._prepareResult(defaultColor);\n    }\n\n    const originalSize = this._getOriginalSize(resource),\n          size = this._prepareSizeAndPosition(originalSize, options);\n\n    if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {\n      this._outputError(options, `incorrect sizes for resource \"${resource.src}\".`);\n\n      return this._prepareResult(defaultColor);\n    }\n\n    if (!this._ctx) {\n      this._canvas = this._makeCanvas();\n      this._ctx = this._canvas.getContext && this._canvas.getContext('2d');\n\n      if (!this._ctx) {\n        this._outputError(options, 'Canvas Context 2D is not supported in this browser.');\n\n        return this._prepareResult(defaultColor);\n      }\n    }\n\n    this._canvas.width = size.destWidth;\n    this._canvas.height = size.destHeight;\n\n    try {\n      this._ctx.clearRect(0, 0, size.destWidth, size.destHeight);\n\n      this._ctx.drawImage(resource, size.srcLeft, size.srcTop, size.srcWidth, size.srcHeight, 0, 0, size.destWidth, size.destHeight);\n\n      const bitmapData = this._ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;\n\n      value = this.getColorFromArray4(bitmapData, options);\n    } catch (e) {\n      this._outputError(options, `security error (CORS) for resource ${resource.src}.\\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image`, e);\n    }\n\n    return this._prepareResult(value);\n  }\n  /**\n   * Get the average color from a array when 1 pixel is 4 bytes.\n   *\n   * @param {Array|Uint8Array} arr\n   * @param {Object} [options]\n   * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n   * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n   * @param {Array}  [options.ignoredColor] [red, green, blue, alpha] \n   * @param {number} [options.step=1]\n   *\n   * @returns {Array} [red (0-255), green (0-255), blue (0-255), alpha (0-255)]\n   */\n\n\n  getColorFromArray4(arr, options) {\n    options = options || {};\n\n    const bytesPerPixel = 4,\n          arrLength = arr.length,\n          defaultColor = this._getDefaultColor(options);\n\n    if (arrLength < bytesPerPixel) {\n      return defaultColor;\n    }\n\n    const len = arrLength - arrLength % bytesPerPixel,\n          step = (options.step || 1) * bytesPerPixel;\n    let algorithm;\n\n    switch (options.algorithm || 'sqrt') {\n      case 'simple':\n        algorithm = simpleAlgorithm;\n        break;\n\n      case 'sqrt':\n        algorithm = sqrtAlgorithm;\n        break;\n\n      case 'dominant':\n        algorithm = dominantAlgorithm;\n        break;\n\n      default:\n        throw Error(`${ERROR_PREFIX}${options.algorithm} is unknown algorithm.`);\n    }\n\n    return algorithm(arr, len, {\n      defaultColor,\n      ignoredColor: options.ignoredColor,\n      step\n    });\n  }\n  /**\n   * Destroy the instance.\n   */\n\n\n  destroy() {\n    delete this._canvas;\n    delete this._ctx;\n  }\n\n  _getDefaultColor(options) {\n    return this._getOption(options, 'defaultColor', [0, 0, 0, 0]);\n  }\n\n  _getOption(options, name, defaultValue) {\n    return typeof options[name] === 'undefined' ? defaultValue : options[name];\n  }\n\n  _prepareSizeAndPosition(originalSize, options) {\n    let srcLeft = this._getOption(options, 'left', 0),\n        srcTop = this._getOption(options, 'top', 0),\n        srcWidth = this._getOption(options, 'width', originalSize.width),\n        srcHeight = this._getOption(options, 'height', originalSize.height),\n        destWidth = srcWidth,\n        destHeight = srcHeight;\n\n    if (options.mode === 'precision') {\n      return {\n        srcLeft,\n        srcTop,\n        srcWidth,\n        srcHeight,\n        destWidth,\n        destHeight\n      };\n    }\n\n    const maxSize = 100,\n          minSize = 10;\n    let factor;\n\n    if (srcWidth > srcHeight) {\n      factor = srcWidth / srcHeight;\n      destWidth = maxSize;\n      destHeight = Math.round(destWidth / factor);\n    } else {\n      factor = srcHeight / srcWidth;\n      destHeight = maxSize;\n      destWidth = Math.round(destHeight / factor);\n    }\n\n    if (destWidth > srcWidth || destHeight > srcHeight || destWidth < minSize || destHeight < minSize) {\n      destWidth = srcWidth;\n      destHeight = srcHeight;\n    }\n\n    return {\n      srcLeft,\n      srcTop,\n      srcWidth,\n      srcHeight,\n      destWidth,\n      destHeight\n    };\n  }\n\n  _bindImageEvents(resource, options) {\n    return new Promise((resolve, reject) => {\n      const onload = () => {\n        unbindEvents();\n        const result = this.getColor(resource, options);\n\n        if (result.error) {\n          reject(result.error);\n        } else {\n          resolve(result);\n        }\n      },\n            onerror = () => {\n        unbindEvents();\n        reject(Error(`${ERROR_PREFIX}Error loading image ${resource.src}.`));\n      },\n            onabort = () => {\n        unbindEvents();\n        reject(Error(`${ERROR_PREFIX}Image \"${resource.src}\" loading aborted.`));\n      },\n            unbindEvents = () => {\n        resource.removeEventListener('load', onload);\n        resource.removeEventListener('error', onerror);\n        resource.removeEventListener('abort', onabort);\n      };\n\n      resource.addEventListener('load', onload);\n      resource.addEventListener('error', onerror);\n      resource.addEventListener('abort', onabort);\n    });\n  }\n\n  _prepareResult(value) {\n    const rgb = value.slice(0, 3),\n          rgba = [].concat(rgb, value[3] / 255),\n          isDark = this._isDark(value);\n\n    return {\n      value,\n      rgb: 'rgb(' + rgb.join(',') + ')',\n      rgba: 'rgba(' + rgba.join(',') + ')',\n      hex: this._arrayToHex(rgb),\n      hexa: this._arrayToHex(value),\n      isDark,\n      isLight: !isDark\n    };\n  }\n\n  _getOriginalSize(resource) {\n    if (resource instanceof HTMLImageElement) {\n      return {\n        width: resource.naturalWidth,\n        height: resource.naturalHeight\n      };\n    }\n\n    if (resource instanceof HTMLVideoElement) {\n      return {\n        width: resource.videoWidth,\n        height: resource.videoHeight\n      };\n    }\n\n    return {\n      width: resource.width,\n      height: resource.height\n    };\n  }\n\n  _toHex(num) {\n    let str = num.toString(16);\n    return str.length === 1 ? '0' + str : str;\n  }\n\n  _arrayToHex(arr) {\n    return '#' + arr.map(this._toHex).join('');\n  }\n\n  _isDark(color) {\n    // http://www.w3.org/TR/AERT#color-contrast\n    const result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;\n    return result < 128;\n  }\n\n  _makeCanvas() {\n    return typeof window === 'undefined' ? new OffscreenCanvas(1, 1) : document.createElement('canvas');\n  }\n\n  _outputError(options, error, details) {\n    if (!options.silent) {\n      console.error(`${ERROR_PREFIX}${error}`);\n\n      if (details) {\n        console.error(details);\n      }\n    }\n  }\n\n}\n\nexport default FastAverageColor;","map":{"version":3,"sources":["/Users/mcneillr/personal/synoptic-project/node_modules/fast-average-color/dist/index.esm.js"],"names":["isIgnoredColor","arr","num","ignoredColor","dominantAlgorithm","len","options","colorHash","divider","i","step","red","green","blue","alpha","key","Math","round","buffer","Object","keys","map","sort","a","b","countA","countB","max","redTotal","greenTotal","blueTotal","alphaTotal","count","defaultColor","simpleAlgorithm","sqrtAlgorithm","sqrt","ERROR_PREFIX","FastAverageColor","getColorAsync","resource","Promise","reject","Error","img","Image","src","_bindImageEvents","complete","result","getColor","error","resolve","_getDefaultColor","value","_outputError","_prepareResult","originalSize","_getOriginalSize","size","_prepareSizeAndPosition","srcWidth","srcHeight","destWidth","destHeight","_ctx","_canvas","_makeCanvas","getContext","width","height","clearRect","drawImage","srcLeft","srcTop","bitmapData","getImageData","data","getColorFromArray4","e","bytesPerPixel","arrLength","length","algorithm","destroy","_getOption","name","defaultValue","mode","maxSize","minSize","factor","onload","unbindEvents","onerror","onabort","removeEventListener","addEventListener","rgb","slice","rgba","concat","isDark","_isDark","join","hex","_arrayToHex","hexa","isLight","HTMLImageElement","naturalWidth","naturalHeight","HTMLVideoElement","videoWidth","videoHeight","_toHex","str","toString","color","window","OffscreenCanvas","document","createElement","details","silent","console"],"mappings":"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","sourcesContent":["/*! Fast Average Color | Â© 2020 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */\nfunction isIgnoredColor(arr, num, ignoredColor) {\n    return arr[num] === ignoredColor[0] && // red\n        arr[num + 1] === ignoredColor[1] && // green\n        arr[num + 2] === ignoredColor[2] && // blue\n        arr[num + 3] === ignoredColor[3]; // alpha\n}\n\nfunction dominantAlgorithm(arr, len, options) {\n    const\n        colorHash = {},\n        divider = 24,\n        ignoredColor = options.ignoredColor;\n\n    for (let i = 0; i < len; i += options.step) {\n        let\n            red = arr[i],\n            green = arr[i + 1],\n            blue = arr[i + 2],\n            alpha = arr[i + 3];\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        const key = Math.round(red / divider) + ',' +\n                Math.round(green / divider) + ',' +\n                Math.round(blue / divider);\n\n        if (colorHash[key]) {\n            colorHash[key] = [\n                colorHash[key][0] + red * alpha,\n                colorHash[key][1] + green * alpha,\n                colorHash[key][2] + blue * alpha,\n                colorHash[key][3] + alpha,\n                colorHash[key][4] + 1\n            ];\n        } else {\n            colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];\n        }\n    }\n\n    const buffer = Object.keys(colorHash).map(key => {\n        return colorHash[key];\n    }).sort((a, b) => {\n        const\n            countA = a[4],\n            countB = b[4];\n\n        return countA > countB ?  -1 : countA === countB ? 0 : 1;\n    });\n\n    const max = buffer[0];\n\n    const redTotal = max[0];\n    const greenTotal = max[1];\n    const blueTotal = max[2];\n\n    const alphaTotal = max[3];\n    const count = max[4];\n\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction simpleAlgorithm(arr, len, options) {\n    let\n        redTotal = 0,\n        greenTotal = 0,\n        blueTotal = 0,\n        alphaTotal = 0,\n        count = 0;\n\n    const ignoredColor = options.ignoredColor;\n\n    for (let i = 0; i < len; i += options.step) {\n        const\n            alpha = arr[i + 3],\n            red = arr[i] * alpha,\n            green = arr[i + 1] * alpha,\n            blue = arr[i + 2] * alpha;\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        redTotal += red;\n        greenTotal += green;\n        blueTotal += blue;\n        alphaTotal += alpha;\n        count++;\n    }\n\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction sqrtAlgorithm(arr, len, options) {\n    let\n        redTotal = 0,\n        greenTotal = 0,\n        blueTotal = 0,\n        alphaTotal = 0,\n        count = 0;\n\n    const ignoredColor = options.ignoredColor;\n\n    for (let i = 0; i < len; i += options.step) {\n        const\n            red = arr[i],\n            green = arr[i + 1],\n            blue = arr[i + 2],\n            alpha = arr[i + 3];\n\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n\n        redTotal += red * red * alpha;\n        greenTotal += green * green * alpha;\n        blueTotal += blue * blue * alpha;\n        alphaTotal += alpha;\n        count++;\n    }\n\n    return alphaTotal ? [\n        Math.round(Math.sqrt(redTotal / alphaTotal)),\n        Math.round(Math.sqrt(greenTotal / alphaTotal)),\n        Math.round(Math.sqrt(blueTotal / alphaTotal)),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nconst ERROR_PREFIX = 'FastAverageColor: ';\n\nclass FastAverageColor {\n    /**\n     * Get asynchronously the average color from not loaded image.\n     *\n     * @param {HTMLImageElement | string | null} resource\n     * @param {Object} [options]\n     * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n     * @param {Array}  [options.ignoredColor] [red, green, blue, alpha]\n     * @param {string} [options.mode=\"speed\"] \"precision\" or \"speed\"\n     * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n     * @param {number} [options.step=1]\n     * @param {number} [options.left=0]\n     * @param {number} [options.top=0]\n     * @param {number} [options.width=width of resource]\n     * @param {number} [options.height=height of resource]\n     * @param {boolean} [options.silent] Disable error output via console.error\n     *\n     * @returns {Promise}\n     */\n    getColorAsync(resource, options) {\n        if (!resource) {\n            return Promise.reject(Error(`${ERROR_PREFIX}call .getColorAsync() without resource.`));\n        } else if (typeof resource === 'string') {\n            const img = new Image();\n            img.src = resource;            \n            return this._bindImageEvents(img, options);\n        } else if (resource.complete) {\n            const result = this.getColor(resource, options);\n            return result.error ? Promise.reject(result.error) : Promise.resolve(result);\n        } else {\n            return this._bindImageEvents(resource, options);\n        }\n    }\n\n    /**\n     * Get the average color from images, videos and canvas.\n     *\n     * @param {HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null} resource\n     * @param {Object} [options]\n     * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n     * @param {Array}  [options.ignoredColor] [red, green, blue, alpha]\n     * @param {string} [options.mode=\"speed\"] \"precision\" or \"speed\"\n     * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n     * @param {number} [options.step=1]\n     * @param {number} [options.left=0]\n     * @param {number} [options.top=0]\n     * @param {number} [options.width=width of resource]\n     * @param {number} [options.height=height of resource]\n     * @param {boolean} [options.silent] Disable error output via console.error\n     *\n     * @returns {Object}\n     */\n    getColor(resource, options) {\n        options = options || {};\n\n        const defaultColor = this._getDefaultColor(options);\n\n        let value = defaultColor;\n        if (!resource) {\n            this._outputError(options, 'call .getColor(null) without resource.');\n\n            return this._prepareResult(defaultColor);\n        }\n\n        const\n            originalSize = this._getOriginalSize(resource),\n            size = this._prepareSizeAndPosition(originalSize, options);\n\n        if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {\n            this._outputError(options, `incorrect sizes for resource \"${resource.src}\".`);\n\n            return this._prepareResult(defaultColor);\n        }\n\n        if (!this._ctx) {\n            this._canvas = this._makeCanvas();\n            this._ctx = this._canvas.getContext && this._canvas.getContext('2d');\n\n            if (!this._ctx) {\n                this._outputError(options, 'Canvas Context 2D is not supported in this browser.');\n\n                return this._prepareResult(defaultColor);\n            }\n        }\n\n        this._canvas.width = size.destWidth;\n        this._canvas.height = size.destHeight;\n\n        try {\n            this._ctx.clearRect(0, 0, size.destWidth, size.destHeight);\n            this._ctx.drawImage(\n                resource,\n                size.srcLeft, size.srcTop,\n                size.srcWidth, size.srcHeight,\n                0, 0,\n                size.destWidth, size.destHeight\n            );\n\n            const bitmapData = this._ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;\n            value = this.getColorFromArray4(bitmapData, options);\n        } catch (e) {\n            this._outputError(options, `security error (CORS) for resource ${resource.src}.\\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image`, e);\n        }\n\n        return this._prepareResult(value);\n    }\n\n    /**\n     * Get the average color from a array when 1 pixel is 4 bytes.\n     *\n     * @param {Array|Uint8Array} arr\n     * @param {Object} [options]\n     * @param {string} [options.algorithm=\"sqrt\"] \"simple\", \"sqrt\" or \"dominant\"\n     * @param {Array}  [options.defaultColor=[0, 0, 0, 0]] [red, green, blue, alpha]\n     * @param {Array}  [options.ignoredColor] [red, green, blue, alpha] \n     * @param {number} [options.step=1]\n     *\n     * @returns {Array} [red (0-255), green (0-255), blue (0-255), alpha (0-255)]\n     */\n    getColorFromArray4(arr, options) {\n        options = options || {};\n\n        const\n            bytesPerPixel = 4,\n            arrLength = arr.length,\n            defaultColor = this._getDefaultColor(options);\n\n        if (arrLength < bytesPerPixel) {\n            return defaultColor;\n        }\n\n        const\n            len = arrLength - arrLength % bytesPerPixel,\n            step = (options.step || 1) * bytesPerPixel;\n\n        let algorithm;\n\n        switch (options.algorithm || 'sqrt') {\n            case 'simple':\n                algorithm = simpleAlgorithm;\n                break;\n            case 'sqrt':\n                algorithm = sqrtAlgorithm;\n                break;\n            case 'dominant':\n                algorithm = dominantAlgorithm;\n                break;\n            default:\n                throw Error(`${ERROR_PREFIX}${options.algorithm} is unknown algorithm.`);\n        }\n\n        return algorithm(arr, len, {\n            defaultColor,\n            ignoredColor: options.ignoredColor,\n            step\n        });\n    }\n\n    /**\n     * Destroy the instance.\n     */\n    destroy() {\n        delete this._canvas;\n        delete this._ctx;\n    }\n\n    _getDefaultColor(options) {\n        return this._getOption(options, 'defaultColor', [0, 0, 0, 0]);\n    }\n\n    _getOption(options, name, defaultValue) {\n        return typeof options[name] === 'undefined' ? defaultValue : options[name];\n    }\n\n    _prepareSizeAndPosition(originalSize, options) {\n        let\n            srcLeft = this._getOption(options, 'left', 0),\n            srcTop = this._getOption(options, 'top', 0),\n            srcWidth = this._getOption(options, 'width', originalSize.width),\n            srcHeight = this._getOption(options, 'height', originalSize.height),\n            destWidth = srcWidth,\n            destHeight = srcHeight;\n\n        if (options.mode === 'precision') {\n            return {\n                srcLeft,\n                srcTop,\n                srcWidth,\n                srcHeight,\n                destWidth,\n                destHeight\n            };\n        }\n\n        const\n            maxSize = 100,\n            minSize = 10;\n\n        let factor;\n\n        if (srcWidth > srcHeight) {\n            factor = srcWidth / srcHeight;\n            destWidth = maxSize;\n            destHeight = Math.round(destWidth / factor);\n        } else {\n            factor = srcHeight / srcWidth;\n            destHeight = maxSize;\n            destWidth = Math.round(destHeight / factor);\n        }\n\n        if (\n            destWidth > srcWidth || destHeight > srcHeight ||\n            destWidth < minSize || destHeight < minSize\n        ) {\n            destWidth = srcWidth;\n            destHeight = srcHeight;\n        }\n\n        return {\n            srcLeft,\n            srcTop,\n            srcWidth,\n            srcHeight,\n            destWidth,\n            destHeight\n        };\n    }\n\n    _bindImageEvents(resource, options) {\n        return new Promise((resolve, reject) => {\n            const onload = () => {\n                    unbindEvents();\n\n                    const result = this.getColor(resource, options);\n\n                    if (result.error) {\n                        reject(result.error);\n                    } else {\n                        resolve(result);\n                    }\n                },\n                onerror = () => {\n                    unbindEvents();\n\n                    reject(Error(`${ERROR_PREFIX}Error loading image ${resource.src}.`));\n                },\n                onabort = () => {\n                    unbindEvents();\n\n                    reject(Error(`${ERROR_PREFIX}Image \"${resource.src}\" loading aborted.`));\n                },\n                unbindEvents = () => {\n                    resource.removeEventListener('load', onload);\n                    resource.removeEventListener('error', onerror);\n                    resource.removeEventListener('abort', onabort);\n                };\n\n            resource.addEventListener('load', onload);\n            resource.addEventListener('error', onerror);\n            resource.addEventListener('abort', onabort);\n        });\n    }\n\n    _prepareResult(value) {\n        const\n            rgb = value.slice(0, 3),\n            rgba = [].concat(rgb, value[3] / 255),\n            isDark = this._isDark(value);\n\n        return {\n            value,\n            rgb: 'rgb(' + rgb.join(',') + ')',\n            rgba: 'rgba(' + rgba.join(',') + ')',\n            hex: this._arrayToHex(rgb),\n            hexa: this._arrayToHex(value),\n            isDark,\n            isLight: !isDark\n        };\n    }\n\n    _getOriginalSize(resource) {\n        if (resource instanceof HTMLImageElement) {\n            return {\n                width: resource.naturalWidth,\n                height: resource.naturalHeight\n            };\n        }\n\n        if (resource instanceof HTMLVideoElement) {\n            return {\n                width: resource.videoWidth,\n                height: resource.videoHeight\n            };\n        }\n\n        return {\n            width: resource.width,\n            height: resource.height\n        };\n    }\n\n    _toHex(num) {\n        let str = num.toString(16);\n        return str.length === 1 ? '0' + str : str;\n    }\n\n    _arrayToHex(arr) {\n        return '#' + arr.map(this._toHex).join('');\n    }\n\n    _isDark(color) {\n        // http://www.w3.org/TR/AERT#color-contrast\n        const result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;\n\n        return result < 128;\n    }\n\n    _makeCanvas() {\n        return typeof window === 'undefined' ?\n            new OffscreenCanvas(1, 1) :\n            document.createElement('canvas');\n    }\n\n    _outputError(options, error, details) {\n        if (!options.silent) {\n            console.error(`${ERROR_PREFIX}${error}`);\n\n            if (details) {\n                console.error(details);\n            }\n        }\n    }\n}\n\nexport default FastAverageColor;\n"]},"metadata":{},"sourceType":"module"}